<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Delve GP/hr</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #111; color: #eee; }
    label { display: block; margin-top: 8px; }
    input { width: 100px; }
    .section { border: 1px solid #444; padding: 10px; margin: 10px 0; }
    canvas { background: #222; }
    /* Add this: */
    canvas#gpChart {
      width: 1200px !important;
      height: 600px !important;
      max-width: 90vw;
      margin: auto;
      display: block;
    }
</style>
</head>
<body>

<h1>Delve GP/hr calc</h1>

<div class="section">
    <h2>Wave Times (seconds)</h2>
    <div id="waveTimesInputs"></div>
</div>

<div class="section">
    <h2>Banking Time (seconds)</h2>
    <input id="bankTime" type="number" value="120">
</div>

<div class="section">
    <h2>Death Rate per wave (8+) (%)</h2>
    <input id="deathRate" type="number" value="0.5">
</div>

<div class="section">
    <h2>Highest wave to check</h2>
    <input id="highestWave" type="number" value="40">
</div>

<div class="section">
    <h2>Item Values (GP)</h2>
    <label>Mokhaiotl Cloth: <input id="valCloth" type="number" value="115000000"></label>
    <label>Eye of Ayak: <input id="valEye" type="number" value="100000000"></label>
    <label>Avernic Treads: <input id="valTreads" type="number" value="300000000"></label>
</div>

<canvas id="gpChart" width="1200" height="600"></canvas>

<div id="details" style="margin-top: 20px; font-size: 0.9em; line-height: 1.4em;"></div>
<script>
const dropRates = {
    cloth: {2: 2500, 3: 2000, 4: 1350, 5: 810, 6: 765, 7: 720, 8: 630, 9: 540},
    eye:   {3: 2000, 4: 1350, 5: 810, 6: 765, 7: 720, 8: 630, 9: 540},
    treads:{4: 1350, 5: 810, 6: 765, 7: 720, 8: 630, 9: 540}
};

// Create wave time inputs
const waveTimesInputsDiv = document.getElementById("waveTimesInputs");
for (let i=1;i<=9;i++) {
    let label = document.createElement("label");
    label.textContent = `Wave ${i} time: `;
    let input = document.createElement("input");
    input.type = "number";
    input.value = i <= 8 ? 60 : 80; // default values
    input.id = `wave${i}`;
    label.appendChild(input);
    waveTimesInputsDiv.appendChild(label);
}

function getExpectedGP(maxWave) {
    const valCloth = parseFloat(document.getElementById("valCloth").value);
    const valEye = parseFloat(document.getElementById("valEye").value);
    const valTreads = parseFloat(document.getElementById("valTreads").value);
    const deathRate = parseFloat(document.getElementById("deathRate").value) / 100;
    const bankTime = parseFloat(document.getElementById("bankTime").value);

    // Probability to survive all the way to maxWave (death rolls only 8+)
    let survivalProb = 1.0;
    for (let wave=8; wave<=maxWave; wave++) {
        survivalProb *= (1 - deathRate);
    }

    // Time per run
    let runTime = 0;
    for (let wave=1; wave<=maxWave; wave++) {
        runTime += parseFloat(document.getElementById(`wave${Math.min(wave,9)}`).value);
    }
    runTime += bankTime;

    // Loot if survive
    let lootValue = 0;
    for (let wave=1; wave<=maxWave; wave++) {
        const w = Math.min(wave, 9); // Waves >9 use wave 9 rates
        if (dropRates.cloth[w]) lootValue += (1 / dropRates.cloth[w]) * valCloth;
        if (dropRates.eye[w]) lootValue += (1 / dropRates.eye[w]) * valEye;
        if (dropRates.treads[w]) lootValue += (1 / dropRates.treads[w]) * valTreads;
    }

    let expectedLoot = lootValue * survivalProb;
    let hoursPerRun = runTime / 3600;
    return expectedLoot / hoursPerRun;
}

function updateChart() {
    const labels = [];
    const data = [];
    const highestWave = parseInt(document.getElementById("highestWave").value) || 20; // fallback
    for (let maxWave = 2; maxWave <= highestWave; maxWave++) {
        labels.push(`Wave ${maxWave}`);

        // Use your new function here
        const stats = getExpectedDropsStopOnUnique(maxWave);
        data.push(stats.expectedGPPerHour);
    }
    gpChart.data.labels = labels;
    gpChart.data.datasets[0].data = data;
    gpChart.update();
}


function getExpectedDropsStopOnUnique(maxWave) {
    const valCloth = parseFloat(document.getElementById("valCloth").value);
    const valEye = parseFloat(document.getElementById("valEye").value);
    const valTreads = parseFloat(document.getElementById("valTreads").value);
    const deathRate = parseFloat(document.getElementById("deathRate").value) / 100;
    const bankTime = parseFloat(document.getElementById("bankTime").value);

    // Cumulative wave times for quick calculation
    const waveTimes = [];
    for (let wave=1; wave<=maxWave; wave++) {
        waveTimes.push(parseFloat(document.getElementById(`wave${Math.min(wave,9)}`).value));
    }

    // Calculate per-wave drop probabilities (any unique)
    // Probability per unique drop type per wave = 1/dropRate, if defined
    // Sum to get total unique drop probability per wave
    // Also keep weighted values for expected drop value if drop occurs on that wave

    let probNoDropBefore = 1.0; // Probability no unique drop before wave w
    let expectedRunTime = 0;
    let expectedValuePerRun = 0;

    for (let wave=1; wave<=maxWave; wave++) {
        const w = Math.min(wave, 9);

        // Prob of each unique drop on this wave
        const pCloth = dropRates.cloth[w] ? 1 / dropRates.cloth[w] : 0;
        const pEye = dropRates.eye[w] ? 1 / dropRates.eye[w] : 0;
        const pTreads = dropRates.treads[w] ? 1 / dropRates.treads[w] : 0;

        const pAnyDrop = pCloth + pEye + pTreads;

        // Probability the run ends exactly at this wave:
        // no drop on all previous waves * drop at this wave
        const pStopAtWave = probNoDropBefore * pAnyDrop;

        // Calculate expected value if drop at this wave (weighted by drop proportions)
        let expectedValueAtWave = 0;
        if (pAnyDrop > 0) {
            expectedValueAtWave += (pCloth / pAnyDrop) * valCloth;
            expectedValueAtWave += (pEye / pAnyDrop) * valEye;
            expectedValueAtWave += (pTreads / pAnyDrop) * valTreads;
        }

        // Calculate total time up to this wave (sum waveTimes up to wave) + bankTime
        const timeUpToWave = waveTimes.slice(0, wave).reduce((a,b) => a+b, 0) + bankTime;

        // Add to expected run time weighted by pStopAtWave
        expectedRunTime += pStopAtWave * timeUpToWave;

        // Add to expected value weighted by pStopAtWave
        expectedValuePerRun += pStopAtWave * expectedValueAtWave;

        // Update probability of no drop before next wave
        probNoDropBefore *= (1 - pAnyDrop);
    }

    // If no drop at all (run ends at maxWave), treat as no loot and time = full run
    // So add the residual probability * full run time

    const pNoDropAtAll = probNoDropBefore;
    const totalTimeFullRun = waveTimes.reduce((a,b) => a+b, 0) + bankTime;
    expectedRunTime += pNoDropAtAll * totalTimeFullRun;
    // No additional loot on no-drop case

    // Convert run time to hours
    const hoursPerRun = expectedRunTime / 3600;

    // Return expected drops per run (in value) and GP/hr
    const gpPerHour = expectedValuePerRun / hoursPerRun;

    return {
        expectedGPPerRun: expectedValuePerRun,
        expectedGPPerHour: gpPerHour,
        expectedRunTimeSeconds: expectedRunTime
    };
}


function getExpectedDrops(maxWave) {
    const valCloth = parseFloat(document.getElementById("valCloth").value);
    const valEye = parseFloat(document.getElementById("valEye").value);
    const valTreads = parseFloat(document.getElementById("valTreads").value);
    const deathRate = parseFloat(document.getElementById("deathRate").value) / 100;
    const bankTime = parseFloat(document.getElementById("bankTime").value);

    // Calculate survival probability for waves 8+
    let survivalProb = 1.0;
    for (let wave = 8; wave <= maxWave; wave++) {
        survivalProb *= (1 - deathRate);
    }

    // Calculate run time
    let runTime = 0;
    for (let wave = 1; wave <= maxWave; wave++) {
        runTime += parseFloat(document.getElementById(`wave${Math.min(wave, 9)}`).value);
    }
    runTime += bankTime;

    // Sum raw drop probabilities (no death adjustment) - expected drops per run
    let drops = {
        cloth: 0,
        eye: 0,
        treads: 0,
    };

    for (let wave = 1; wave <= maxWave; wave++) {
        const w = Math.min(wave, 9);
        if (dropRates.cloth[w]) drops.cloth += 1 / dropRates.cloth[w];
        if (dropRates.eye[w]) drops.eye += 1 / dropRates.eye[w];
        if (dropRates.treads[w]) drops.treads += 1 / dropRates.treads[w];
    }

    // Expected drops per run (no death)
    const expectedDropsPerRun = {
        cloth: drops.cloth,
        eye: drops.eye,
        treads: drops.treads,
    };

    // Expected drops per hour (accounting for death chance)
    const hoursPerRun = runTime / 3600;
    const expectedDropsPerHour = {
        cloth: (expectedDropsPerRun.cloth * survivalProb) / hoursPerRun,
        eye: (expectedDropsPerRun.eye * survivalProb) / hoursPerRun,
        treads: (expectedDropsPerRun.treads * survivalProb) / hoursPerRun,
    };

    return { expectedDropsPerRun, expectedDropsPerHour };
}


const ctx = document.getElementById('gpChart').getContext('2d');
const gpChart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: 'GP/hr',
            data: [],
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.1
        }]
    },
    options: {
        scales: { y: { beginAtZero: true } }
    }
});

document.getElementById('gpChart').onclick = function(evt) {
    const points = gpChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);
    if (points.length) {
        const firstPoint = points[0];
        const wave = firstPoint.index + 2; // waves start from 2
        const drops = getExpectedDrops(wave);

        const valCloth = parseFloat(document.getElementById("valCloth").value);
        const valEye = parseFloat(document.getElementById("valEye").value);
        const valTreads = parseFloat(document.getElementById("valTreads").value);

        const gpPerRunCloth = drops.expectedDropsPerRun.cloth * valCloth;
        const gpPerRunEye = drops.expectedDropsPerRun.eye * valEye;
        const gpPerRunTreads = drops.expectedDropsPerRun.treads * valTreads;

        const gpPerHourCloth = drops.expectedDropsPerHour.cloth * valCloth;
        const gpPerHourEye = drops.expectedDropsPerHour.eye * valEye;
        const gpPerHourTreads = drops.expectedDropsPerHour.treads * valTreads;

        document.getElementById('details').innerHTML = `
            <b>Wave ${wave} stats:</b><br>
            Expected drops <i>per run</i>:<br>
            &nbsp; Mokhaiotl Cloth: ${drops.expectedDropsPerRun.cloth.toFixed(4)} (GP: ${gpPerRunCloth.toLocaleString()})<br>
            &nbsp; Eye of Ayak: ${drops.expectedDropsPerRun.eye.toFixed(4)} (GP: ${gpPerRunEye.toLocaleString()})<br>
            &nbsp; Avernic Treads: ${drops.expectedDropsPerRun.treads.toFixed(4)} (GP: ${gpPerRunTreads.toLocaleString()})<br><br>

            Expected drops <i>per hour</i>:<br>
            &nbsp; Mokhaiotl Cloth: ${drops.expectedDropsPerHour.cloth.toFixed(4)} (GP/hr: ${gpPerHourCloth.toLocaleString()})<br>
            &nbsp; Eye of Ayak: ${drops.expectedDropsPerHour.eye.toFixed(4)} (GP/hr: ${gpPerHourEye.toLocaleString()})<br>
            &nbsp; Avernic Treads: ${drops.expectedDropsPerHour.treads.toFixed(4)} (GP/hr: ${gpPerHourTreads.toLocaleString()})
        `;
    }
};



document.querySelectorAll("input").forEach(inp => inp.addEventListener("input", updateChart));
updateChart();
</script>

</body>
</html>
